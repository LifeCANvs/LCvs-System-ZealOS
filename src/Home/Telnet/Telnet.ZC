// Telnet client for ZealOS by y4my4m
// Public Domain

#define TELNET_PORT 23
#define BUF_SIZE 5120 // way too big?
#define TIMEOUT_DURATION 5000

I64 TelnetOpen(U8 *host, U16 port) {
  I64 sock;

  if (host == NULL) {
    return -1;
  }

  sock = TCPConnectionCreate(host, port);
  "$$RED$$Conecting to %s:%d.$$FG$$$$BG$$\n", host, port;
  if (sock <= 0) {
    PrintErr("Failed to connect to %s:%d\n", host, port);
    return sock;
  }

	// sock(CTCPSocket *)->timeout = TCP_TIMEOUT;
  
  return sock;
}

U0 AppendColorString(I64 color_code) {
  U8 *color;
  switch (color_code) {
    case 0: color = "$$BLACK$$"; break;
    case 1: color = "$$RED$$"; break;
    case 2: color = "$$GREEN$$"; break;
    case 3: color = "$$YELLOW$$"; break;
    case 4: color = "$$BLUE$$"; break;
    case 5: color = "$$BROWN$$"; break;
    case 6: color = "$$CYAN$$"; break;
    case 7: color = "$$WHITE$$"; break;
    default: color = ""; break;
  }
  "%s", color;
}

U0 SendWindowSize(I64 sock, U16 rows, U16 cols) {
  U8 buf[9];

  buf[0] = 0xFF; // IAC
  buf[1] = 0xFA; // SB
  buf[2] = 0x1F; // NAWS (Negotiate About Window Size)
  buf[3] = cols >> 8; // High byte of columns
  buf[4] = cols & 0xFF; // Low byte of columns
  buf[5] = rows >> 8; // High byte of rows
  buf[6] = rows & 0xFF; // Low byte of rows
  buf[7] = 0xFF; // IAC
  buf[8] = 0xF0; // SE

  TCPSocketSendString(sock, buf);
}

U0 SendTerminalType(I64 sock, U8 *terminal_type) {
  U8 response[256];
  I64 len = StrLen(terminal_type);

  response[0] = 0xFF; // IAC
  response[1] = 0xFA; // SB
  response[2] = 0x18; // TERMINAL TYPE
  response[3] = 0x00; // IS
  MemCopy(response + 4, terminal_type, len);

  response[len + 4] = 0xFF; // IAC
  response[len + 5] = 0xF0; // SE
  response[len + 6] = '\0';
  TCPSocketSendString(sock, response);
  // Free(response); ??
}

U0 HandleControlCodes(U8 ch) {
  if (ch < 32 && ch != 20) { // ASCII code below 32 (control character)
    switch (ch) {
      case 0: // NUL (Null)
        // Typically ignored
        break;
      case 7: // BEL (Bell)
        // Make a beep sound or flash the screen
        Beep;
        break;
      case 8: // BS (Backspace)
        // "%c%c%c", 8, ' ', 8; // Move cursor back, erase character, move cursor back again
        break;
      case 9: // HT (Horizontal Tab)
        // Move the cursor to the next tab stop (typically 8 spaces)
        break;
      case 10: // LF (Line Feed)
        // "%c", ch;
        break;
      case 11: // VT (Vertical Tab)
        // Move the cursor down one line
        break;
      case 12: // FF (Form Feed)
        DocClear;
        break;
      case 13: // CR (Carriage Return)
        "\r\n\0";
        break;
      case 14: // SO (Shift Out)
        // Switch to an alternate character set
        break;
      case 15: // SI (Shift In)
        // Switch back to the default character set
        break;
      default:
        break;
    }
  } else {
    // SysLog("Code: 0x%02X\n", ch);
    "%c", ch;
  }
}

U0 HandleMCICode(U8 *ptr, I64 *index) {
  // U8 code[4];
  // MemCopy(code, ptr + *index, 3);
  // *index += 3;

  // if (StrCompare(code, "ET1") == 0) {
  //   // Handle ET1 MCI code here
  // }
  // SysLog("MCI code: %s\n", code);
  // Add support for other MCI codes if needed
}

U0 Telnet(U8 *host, U16 port=TELNET_PORT) {
  I64 sock, bytes_received, input_len, sc = 0;
  U8 buffer[BUF_SIZE], input_buffer[BUF_SIZE], *ptr, ch;
  Bool force_disconnect = FALSE;

  I64 window_width = 80;
  // I64 window_height = 25; // 25 should be default
  I64 window_height = 40;

  I64 window_left = (GR_WIDTH - window_width) / 2;
  I64 window_top = (Fs->win_bottom - Fs->win_top - window_height) / 2;

  WinHorz(Fs->win_left, Fs->win_left+80, Fs);
  WinVert(Fs->win_top + window_top, Fs->win_top + window_top + window_height, Fs);
  WinToTop(Fs);
  WinFocus(Fs);

  DocClear;

  sock = TelnetOpen(host, port);
  if (sock <= 0) {
    return;
  }

  "$$BG,RED$$$$WHITE$$Connected$$FG$$$$BG$$\n";

  while (!force_disconnect) {
    bytes_received = TCPSocketReceive(sock, buffer, BUF_SIZE - 1);
    if (bytes_received > 0) {
      buffer[bytes_received] = '\0';

      // Basic Telnet protocol parser
      ptr = buffer;
      while (*ptr) {
        // SysLog("BUF: 0x%02X\n", *ptr);
        if (*ptr == 0xFF) { // Telnet negotiation sequence
          U8 negotiation_code = *(ptr + 1);
          U8 option_code = *(ptr + 2);

          // Send a response to the server
          U8 response[3];
          response[0] = 0xFF; // IAC

          if (negotiation_code == 0xFD || negotiation_code == 0xFE) { // DO or DONT
            if (option_code == 0x01) { // Echo
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
              } else {
                response[1] = 0xFC; // WONT
              }
            } else if (option_code == 0x03) { // Suppress Go Ahead
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
              } else {
                response[1] = 0xFC; // WONT
              }
            } else if (option_code == 0x18) { // Terminal Type
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
                response[2] = option_code;
                response[3] = '\0';
                TCPSocketSendString(sock, response);
                Sleep(5000);
                SendTerminalType(sock, "ANSI");
                // Sleep(1000);
                // SendWindowSize(sock, 25, 80);
                ptr += 3;
              } else {
                response[1] = 0xFC; // WONT
              }
            } else {
              response[1] = 0xFC; // WONT
            }
          } else { // WILL or WONT
            response[1] = 0xFE; // DONT
          }

          response[2] = option_code;
          response[3] = '\0';
          TCPSocketSendString(sock, response);
          ptr += 3;
        } else if (*ptr == 0x1B) {
          // ANSI escape sequence
          ptr++;
          if (*ptr == '[') {
            ptr++;
            I64 ansi_code;
            while (1) {
              ansi_code = 0;
              while (*ptr >= '0' && *ptr <= '9') {
                ansi_code = ansi_code * 10 + (*ptr - '0');
                // HandleControlCodes(*ptr);
                ptr++;
              }
              // Process ansi_code
              if (*ptr == ';') {
                ptr++; // Move to the next part of the sequence
              } else if (*ptr == 'm') {
                ptr++;
                I64 color_code;
                if (ansi_code >= 30 && ansi_code <= 37) {
                  //Set foreground color
                  // "%s", AppendColorString(ansi_code - 30);
                  color_code = ansi_code - 30;
                } else if (ansi_code >= 40 && ansi_code <= 47) {
                  // Set background color
                  color_code = ansi_code - 40;
                  // "%s", AppendColorString(ansi_code - 40);
                }
                switch (color_code) {
                  case 0: "$$BLACK$$"; break;
                  case 1: "$$RED$$"; break;
                  case 2: "$$GREEN$$"; break;
                  case 3: "$$YELLOW$$"; break;
                  case 4: "$$BLUE$$"; break;
                  case 5: "$$BROWN$$"; break;
                  case 6: "$$CYAN$$"; break;
                  case 7: "$$WHITE$$"; break;
                  default: break;
                }
                break;
              } else if (*ptr == 'H') {
                // TODO: Handle cursor positioning
                ptr++;
                break;
              } else if (*ptr == 'J') {
                // TODO: Handle screen clearing
                DocClear;
                ptr++;
                break;
              } else if (*ptr == 'K') {
                // TODO: Handle line clearing
                ptr++;
                break;
              } else if (*ptr == 'C') {
                // Custom 'C' escape code for centering text
                // TODO: Handle the centering here
                ptr++;
                break;
              } else if (*ptr == '?') {
                ptr++; // Skip the '?'
              } else if (*ptr == 'h' || *ptr == 'l') {
                // TODO: Handle 'h' (set mode) or 'l' (reset mode) codes
                ptr++; // Skip 'h' or 'l'
                break;
              } else {
                ptr++;
                break; // Invalid character, exit loop
              }
            }
          }
          else if (*ptr == ';') {
            SysLog("; event\n");
            ptr++;
          }
        } else if (*ptr == '%' || *ptr == '|') {
          // MCI code detected
          ptr++;
          HandleMCICode(ptr, &ptr);
          ptr++;
        } else {
          // Print the received character
          HandleControlCodes(*ptr);
          ptr++;
        }
      }

      // Sleep(2000);
      // Prompt user for input and send it to the remote host
      "\n$$RED$$$BK,1$Input$BK,0$$$BLACK$$: ";

      U8 *line = input_buffer;
      U8 *end_of_line = line;
      while (1) {
        switch (KeyGet(&sc))
        {
          case 0:
            switch (sc.u8[0])
            {
              case SC_CURSOR_UP:
                TCPSocketSendString(sock, "CU01");
                SysLog("Cursor up");
                break;
              case SC_CURSOR_DOWN:
                TCPSocketSendString(sock, "CD01");
                SysLog("Cursor down");
                break;
              case SC_CURSOR_LEFT:
                TCPSocketSendString(sock, "CB01");
                SysLog("Cursor left");
                if (line > input_buffer) {
                  line--;
                  "%c", 8;
                }
                break;
              case SC_CURSOR_RIGHT:
                SysLog("Cursor right");
                TCPSocketSendString(sock, "CF01");
                if (line < end_of_line) {
                  "%c", *line++;
                }
                break;
              default:
                break;
            }
          default:
            break;
        }
        ch = CharGet(, FALSE);
        if (ch == '\r' || ch == '\n') {
          break;
        }
        else if (ch == CH_SHIFT_ESC) { // ESC key
          force_disconnect = TRUE;
          break;
        }
        // if (ch == CH_BACKSPACE || ch == 127) { // Backspace or Delete key
        //   if (line != input_buffer) {
        //     line--; // Move the pointer back
        //     "%c%c%c", 8, ' ', 8; // Move the cursor back, erase the character, and move the cursor back again
        //   }
        // } 
        // *line++ = ch;
        "%c", ch;
      }
      // *line++ = '\r';
      // *line++ = '\n';
      // *line = '\0';
      
      if (!force_disconnect) {
        // SysLog("Sending: %s\n", input_buffer);
        TCPSocketSendString(sock, input_buffer);
        // input_buffer[BUF_SIZE] = 0;
        // cant send line? its not a string but input_buffer is?
        // TCPSocketSendString(sock, line);
        // TCPSocketSend(sock, line, 16);
      } else {
        "Force disconnecting...\n";
        break;
      }
    } else {
      // SysLog("Error: %0x%02X\n", ch);
      "Error: Connection closed by the remote host.\n";
      break;
    }
  }

  TCPSocketClose(sock);
  "Telnet connection closed.\n";
}


class CHostForm {
  U8 host[256] format "$$DA-P,LEN=255,A=\"Host:%s\"$$";
  U16 port format "A=\"Port:%d\"";
};

U0 TelnetPrompt() {
  CHostForm form;

  form.host[0] = 0;
  form.port = TELNET_PORT;
  if (PopUpForm(&form)) {
    Telnet(form.host, form.port);
  }
}

// Dev auto-connect to test server
// Telnet("mbrserver.com");
// Telnet("freechess.org");
// Telnet("dura-bbs.net", 6359);
// Telnet("darkrealms.ca");

// ZealBBS dev server
Telnet("localhost", 8888);