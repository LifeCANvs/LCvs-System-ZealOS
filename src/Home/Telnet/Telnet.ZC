// Telnet client for ZealOS by y4my4m
// Public Domain

#define TELNET_PORT 23
#define BUF_SIZE 2048 // way too big?
#define TIMEOUT_DURATION 5000

#define NEGOTIATE 0xFF
#define IAC 0xFF
#define WILL 0xFB
#define WONT 0xFC
#define DO 0xFD
#define DONT 0xFE
#define ECHO 0x01
#define SUPPRESS_GO_AHEAD 0x03
#define TERMINAL_TYPE 0x18
#define NAWS 0x1F
#define IS 0x00
#define SE 0xF0

#define ANSI_ESC 0x1B
#define ANSI_CSI 0x5B // [

I64 TelnetOpen(U8 *host, U16 port) {
  I64 sock;

  if (host == NULL) {
    return -1;
  }

  sock = TCPConnectionCreate(host, port);
  "$$RED$$Conecting to %s:%d.$$FG$$$$BG$$\n", host, port;
  if (sock <= 0) {
    PrintErr("Failed to connect to %s:%d\n", host, port);
    return sock;
  }

	//sock(CTCPSocket *)->timeout = TCP_TIMEOUT;
  
  return sock;
}

U0 AppendColorString(I64 color_code) {
  U8 *color;
  switch (color_code) {
    case 0: color = "$$BLACK$$"; break;
    case 1: color = "$$RED$$"; break;
    case 2: color = "$$GREEN$$"; break;
    case 3: color = "$$YELLOW$$"; break;
    case 4: color = "$$BLUE$$"; break;
    case 5: color = "$$BROWN$$"; break;
    case 6: color = "$$CYAN$$"; break;
    case 7: color = "$$WHITE$$"; break;
    default: color = ""; break;
  }
  "%s", color;
}

U0 SendWindowSize(I64 sock, U16 rows, U16 cols) {
  U8 buf[9];

  buf[0] = 0xFF; // IAC
  buf[1] = 0xFA; // SB
  buf[2] = 0x1F; // NAWS (Negotiate About Window Size)
  buf[3] = cols >> 8; // High byte of columns
  buf[4] = cols & 0xFF; // Low byte of columns
  buf[5] = rows >> 8; // High byte of rows
  buf[6] = rows & 0xFF; // Low byte of rows
  buf[7] = 0xFF; // IAC
  buf[8] = 0xF0; // SE

  TCPSocketSendString(sock, buf);
}

U0 SendTerminalType(I64 sock, U8 *terminal_type) {
  U8 response[256];
  I64 len = StrLen(terminal_type);

  response[0] = 0xFF; // IAC
  response[1] = 0xFA; // SB
  response[2] = 0x18; // TERMINAL TYPE
  response[3] = 0x00; // IS
  MemCopy(response + 4, terminal_type, len);

  response[len + 4] = 0xFF; // IAC
  response[len + 5] = 0xF0; // SE
  response[len + 6] = '\0';
  TCPSocketSendString(sock, response);
}

U0 HandleControlCodes(U8 ch) {
  if (ch < 32 && ch != 20) { // ASCII code below 32 (control character)
    switch (ch) {
      case 0: // NUL (Null)
        // Typically ignored
        break;
      case 7: // BEL (Bell)
        // Make a beep sound or flash the screen
        Beep;
        break;
      case 8: // BS (Backspace)
        // "%c%c%c", 8, ' ', 8; // Move cursor back, erase character, move cursor back again
        break;
      case 9: // HT (Horizontal Tab)
        // Move the cursor to the next tab stop (typically 8 spaces)
        break;
      case 10: // LF (Line Feed)
        // "%c", ch;
        break;
      case 11: // VT (Vertical Tab)
        // Move the cursor down one line
        break;
      case 12: // FF (Form Feed)
        DocClear;
        break;
      case 13: // CR (Carriage Return)
        "\r\n\0";
        break;
      case 14: // SO (Shift Out)
        // Switch to an alternate character set
        break;
      case 15: // SI (Shift In)
        // Switch back to the default character set
        break;
      default:
        break;
    }
  } 
  else {
    // switch (ch) {
    //   // if (ch > 126) break;
    //   // not sure if there's any point looking for these codes here?
    //   case 0x0A: // Line Feed
    //   case 0x0C: // Form Feed
    //     break;
    //   case 0x0D: // Carriage Return
    //     "\r\0";
    //     break;
    //   case 0x1B: // Escape
    //     break;
    //   case 0x24: // FIXME: Need to escape the dollar sign
    //     ch = "//$$$$";
    //     break;
    //   default:
    //     // SysLog("Code: 0x%02X\n", ch);
    //     break;
    // }
    if (ch == 0x24) {
      ch = "//$$$$";
    }
    "%c", ch;
  }
}

U0 Telnet(U8 *host, U16 port=TELNET_PORT) {
  I64 sock, bytes_received, input_len, sc = 0;
  U8 buffer[BUF_SIZE], input_buffer[BUF_SIZE], *ptr, ch;
  Bool force_disconnect = FALSE;

  I64 window_width = 80;
  I64 window_height = 25; // 25 should be default

  I64 window_left = (GR_WIDTH - window_width) / 2;
  I64 window_top = (Fs->win_bottom - Fs->win_top - window_height) / 2;

  WinHorz(Fs->win_left, Fs->win_left+80, Fs);
  WinVert(Fs->win_top + window_top, Fs->win_top + window_top + window_height, Fs);
  WinToTop(Fs);
  WinFocus(Fs);

  DocClear;

  sock = TelnetOpen(host, port);
  if (sock <= 0) {
    return;
  }

  "$$BG,RED$$$$WHITE$$Connected$$FG$$$$BG$$\n";

  while (!force_disconnect) {
    bytes_received = TCPSocketReceive(sock, buffer, BUF_SIZE - 1);
    if (bytes_received > 0) {
      buffer[bytes_received] = '\0';

      // Basic Telnet protocol parser
      ptr = buffer;
      while (*ptr) {
         // Telnet negotiation sequence
        if (*ptr == NEGOTIATE) {
          U8 negotiation_code = *(ptr + 1);
          U8 option_code = *(ptr + 2);

          // Send a response to the server
          U8 response[4];
          response[0] = IAC;

          if (negotiation_code == DO || negotiation_code == DO) {
            if (option_code == ECHO) {
              if (negotiation_code == DO) {
                response[1] = WILL;
              } else {
                response[1] = WONT;
              }
            } else if (option_code == SUPPRESS_GO_AHEAD) { 
              if (negotiation_code == DO) {
                response[1] = WILL;
              } else {
                response[1] = WONT;
              }
            } else if (option_code == TERMINAL_TYPE) {
              if (negotiation_code == DO) {
                response[1] = WILL;
                response[2] = option_code;
                response[3] = '\0';
                TCPSocketSendString(sock, response);
                SendTerminalType(sock, "ANSI");
                SendWindowSize(sock, 25, 80);
              } else {
                response[1] = WONT;
              }
            } else {
              response[1] = WONT;
            }
          } else {
            response[1] = DONT;
          }

          response[2] = option_code;
          response[3] = '\0';
          TCPSocketSendString(sock, response);
          ptr += 3;
        } 
        else if (*ptr == ANSI_ESC) {
          // ANSI escape sequence
          ptr++;
          if (*ptr == ANSI_CSI) {
            ptr++;
            I64 ansi_code;
            while (1) {
              ansi_code = 0;
              while (*ptr >= '0' && *ptr <= '9') {
                ansi_code = ansi_code * 10 + (*ptr - '0');
                ptr++;
              }
              // Process ansi_code
              if (*ptr == ';') {
                ptr++;
              } else if (*ptr == 'A') {
                // TODO: Cursor Up
                // arg = isNaN(args[0]) ? 1 : args[0];
                // self.moveCursor(0, -arg);
                ptr++;
                break;
              } else if (*ptr == 'B') {
                // TODO: Cursor Down
                // arg = isNaN(args[0]) ? 1 : args[0];
                // self.moveCursor(0, arg);
                ptr++;
                break;
              } else if (*ptr == 'C') {
                // Cursor Right
                I64 i;
                for (i = 0; i < ansi_code; i++) {
                  Print(" ");
                }
                // arg = isNaN(args[0]) ? 1 : args[0];
                // self.moveCursor(arg, 0);
                ptr++;
                break;
              } else if (*ptr == 'D') {
                // TODO: Cursor Left
                // arg = isNaN(args[0]) ? 1 : args[0];
                // self.moveCursor(-arg, 0);
                ptr++;
                break;
              } else if (*ptr == 'E') {
                Print("\n");
                ptr++;
                break;
              } else if (*ptr == 'H' || *ptr == 'f') {
                // TODO: Cursor Position
                // self.row = isNaN(args[0]) ? 1 : args[0];
                // self.column = isNaN(args[1]) ? 1 : args[1];
                // self.positionUpdated();
                SysLog("H detected");
                ptr++;
                break;
              } else if (*ptr == 'J') {
                // TODO: Erase in Display
                DocClear;
                ptr++;
                break;
              } else if (*ptr == 'K') {
                // TODO: Erase in Line
                ptr++;
                break;
              } else if (*ptr == 'S') {
                // TODO: Scroll Up
                ptr++;
                break;
              } else if (*ptr == 'T') {
                // TODO: Scroll Down
                ptr++;
                break;
              } else if (*ptr == '?') {
                switch (ansi_code) {
                  case 25:
                    if (*ptr == 'l') // Hide cursor
                      break;
                    if (*ptr == 'h') // Show cursor
                      break;
                    SysLog("code 25");
                    break;
                  case 1049:
                    if (*ptr == 'h') // Save screen and switch to alternate screen buffer
                        break;
                    if (*ptr == 'l') // Restore screen and switch back to main screen buffer
                        break;
                    SysLog("code 1049");
                    break;
                }
                ptr++;
                break;
              } else if (*ptr == 's') {
                // self.saveCursorPosition();
                ptr++;
                break;
              } else if (*ptr == 'r') {
                // self.restoreCursorPosition();
                ptr++;
                break;
              } else if (*ptr == 'm') {
                switch (ansi_code) {
                  case 0: "$$BG$$$$FG$$"; break; // reset
                  // case 1: ""; break; // TODO: bold
                  // case 2: ""; break; // TODO: dim
                  // case 3: ""; break; // TODO: italic
                  // case 4: "$$UL,1$$" + string + "$$UL,0$$"; break; // TODO: underline
                  // case 5: "$$"; break; // TODO: blink
                  // case 6: ""; break; // TODO: fast blink
                  // case 7: "$$IV,1$$" + string + "$$IV,0$$"; break; // TODO: invert
                  // case 8: ""; break; // TODO: hide (rare)
                  // case 9: ""; break; // TODO: strikethrough
                  // case 10: ""; break; // TODO: primary font
                }
                I64 color_code;
                if (ansi_code >= 30 && ansi_code <= 37) {
                  color_code = ansi_code - 30; // Set foreground color
                } else if (ansi_code >= 40 && ansi_code <= 47) {
                  color_code = ansi_code - 40; // Set background color
                }
                switch (color_code) {
                  case 0: "$$BLACK$$"; break;
                  case 1: "$$RED$$"; break;
                  case 2: "$$GREEN$$"; break;
                  case 3: "$$YELLOW$$"; break;
                  case 4: "$$BLUE$$"; break;
                  case 5: "$$BROWN$$"; break;
                  case 6: "$$CYAN$$"; break;
                  case 7: "$$WHITE$$"; break;
                  default: break;
                }
                ptr++;
                break;
              } else if (*ptr == 'h' || *ptr == 'l') {
                // TODO: Handle 'h' (set mode) or 'l' (reset mode) codes
                ptr++; // Skip 'h' or 'l'
                break;
              } else {
                ptr++;
                break; // Invalid character, exit loop
              }
            }
          }
        }
        else {
          // Print the received character
          HandleControlCodes(*ptr);
          ptr++;
        }
      }

      // Sleep(500);
      // Prompt user for input and send it to the remote host
      "\n$$RED$$$BK,1$Input$BK,0$$$BLACK$$: ";

      U8 *line = input_buffer;
      input_len = 0;
      while (1) {
        ch = CharGet(, FALSE);
        if (ch == '\r' || ch == '\n') {
          break;
        }
        else if (ch == CH_SHIFT_ESC) { // ESC key
          force_disconnect = TRUE;
          break;
        }
        input_buffer[input_len++] = ch;
        "%c", ch;
      }
      input_buffer[input_len] = '\0';
      
      if (!force_disconnect) {
        input_buffer[input_len++] = '\r';
        input_buffer[input_len++] = '\n';
        TCPSocketSend(sock, input_buffer, input_len);
      } else {
        "Force disconnecting...\n";
        goto disconnect;
        break;
      }
    } else {
      // SysLog("Error: %0x%02X\n", ch);
      "Error: Connection closed by the remote host.\n";
      break;
    }
  }
disconnect:
  TCPSocketClose(sock);
  "Telnet connection closed.\n";
}


class CHostForm {
  U8 host[256] format "$$DA-P,LEN=255,A=\"Host:%s\"$$";
  U16 port format "A=\"Port:%d\"";
};

U0 TelnetPrompt() {
  CHostForm form;

  form.host[0] = 0;
  form.port = TELNET_PORT;
  if (PopUpForm(&form)) {
    Telnet(form.host, form.port);
  }
}

// Dev auto-connect to test server
// Telnet("mbrserver.com");
// Telnet("freechess.org");
// Telnet("dura-bbs.net", 6359);
// Telnet("darkrealms.ca");

// good to test refresh, line feed, etc
// Telnet("20forbeers.com", 1337);

// ZealBBS dev server
Telnet("localhost", 8888);