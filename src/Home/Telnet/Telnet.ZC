// Telnet client for ZealOS by y4my4m
// Public Domain

#define TELNET_PORT 23
#define BUF_SIZE 8192 // way too big?
#define TIMEOUT_DURATION 5000

#define NEGOTIATE 0xFF

#define ANSI_ESC 0x1B
#define ANSI_CSI 0x5B // [

#define MAX_ANSI_PARAMS 256

CTask *input_task	= NULL;
Bool force_disconnect = FALSE;
Bool input_request = FALSE;

U8 IsDigit(U8 ch) {
  return '0' <= ch <= '9';
}

U0 HandleControlCodes(U8 ch) {
  if (ch < 32) { // ASCII code below 32 (control character)
    switch (ch) {
      case 0: // NUL (Null) - Typically ignored
        break;
      case 7: // BEL (Bell)
        // Beep;
        break;
      case 8: // BS (Backspace)
        "%c%c%c", 8, ' ', 8; // Move cursor back, erase character, move cursor back again
        break;
      case 9: // HT (Horizontal Tab)
        "        "; // 8 spaces
        break;
      case 10: // LF (Line Feed)
        "\n";
        break;
      case 11: // VT (Vertical Tab)
        break;
      case 12: // FF (Form Feed)
        DocClear;
        break;
      case 13: // CR (Carriage Return)
        "\r";
        break;
      case 14: // SO (Shift Out) - Switch to an alternate character set
      case 15: // SI (Shift In)  - Switch back to the default character set
      default:
        break;
    }
  } 
  else {
    if (ch == 127) {
        SysLog("case 127");
    }
    if (ch == 0x24) {
      // ch = "//$$$$";
    }
    "%c", ch;
  }
}

I64 TelnetOpen(U8 *host, U16 port) {
  I64 sock;

  if (host == NULL) {
    return -1;
  }

  sock = TCPConnectionCreate(host, port);
  "$$RED$$Conecting to %s:%d.$$FG$$$$BG$$\n", host, port;
  if (sock <= 0) {
    PrintErr("Failed to connect to %s:%d\n", host, port);
    return sock;
  }

	// sock(CTCPSocket *)->timeout = TCP_TIMEOUT;
  
  return sock;
}

U0 InputTask(U0 *args) {
  I64 sock = *args;

	DocTermNew;
	DocPrint(, "$$WW,1$$");
  // DocCursor;
  // WinBorder(OFF);

  U8 input_buffer[BUF_SIZE];
  U8 *temp, ch;
  U8 *line = input_buffer;
  I64 input_len = 0;

  while (!force_disconnect) {
    if (!input_request) {

      DocBottom(input_task->put_doc);
      "\n$$RED$$$BK,1$Input$BK,0$$$BLACK$$:";

      // https://theasciicode.com.ar/ascii-control-characters/escape-ascii-code-27.html
      input_len = 0;
      while (1) {
        ch = CharGet(, FALSE);
        if (ch == '\r' || ch == '\n') {
          // input_buffer[input_len++] = '\r';
          // input_buffer[input_len++] = '\n';
          break;
        }
        else if (ch == CH_SHIFT_ESC) {
          force_disconnect = TRUE;
          break;
        }
        else if (ch == CH_ESC) {
          TCPSocketSendString(sock, 0x27);
          break;
        }
        else if (ch == CH_BACKSPACE) {
          break;
        }
        else if (ch == 0x0F) { // TAB?
          TCPSocketSendString(sock, 0x09);
          break;
        }
        else {
          input_buffer[input_len++] = ch;
          DocPrint(input_task->put_doc, "%c", ch);
        }
      }
      
      if (!force_disconnect) {
        SysLog(input_buffer);
        temp = MStrPrint("%s\r\n", input_buffer);

        TCPSocketSendString(sock, temp);
        Free(temp);
        MemSet(input_buffer, 0, BUF_SIZE);
        DocClear;
        
      } else {
        "Force disconnecting...\n";
        break;
      }
    }
  }
}

U0 Telnet(U8 *host, U16 port=TELNET_PORT) {
  
  I64 sock, bytes_received, input_len, sc;
  U8 buffer[BUF_SIZE], *ptr;

  I64 window_width = 80;
  I64 window_height = 25;

  I64 window_left = (GR_WIDTH - window_width) / 2;
  I64 window_top = (Fs->win_bottom - Fs->win_top - window_height) / 2;

	// DocPrint(, "$$WW,1$$");
  WinHorz(Fs->win_left, Fs->win_left+window_width, Fs);
  WinVert(Fs->win_top + window_top, Fs->win_top + window_top + window_height, Fs);
  // DocCursor(OFF);

  // WinToTop(Fs);
  // WinFocus(Fs);

  sock = TelnetOpen(host, port);
  if (sock <= 0) {
    return;
  }

	input_task = Spawn(&InputTask, &sock, "Telnet Input");
	input_task->win_inhibit = WIG_USER_TASK_DEFAULT;
	LBts(&input_task->display_flags, DISPLAYf_SHOW);
	WinFocus(input_task);

  input_task->win_top = Fs->win_top + window_top;
	input_task->win_bottom = Fs->win_top + 40;
	input_task->win_left	= Fs->win_left;
	input_task->win_right	= Fs->win_left+window_width;

  DocClear;

  "$$BG,RED$$$$WHITE$$Connected$$FG$$$$BG$$\n";

  while (!force_disconnect) {
    bytes_received = TCPSocketReceive(sock, buffer, BUF_SIZE - 1);
    if (bytes_received > 0) {
      buffer[bytes_received] = '\0';

      // Basic Telnet protocol parser
      ptr = buffer;
      while (*ptr) {
         // Telnet negotiation sequence
        if (*ptr == NEGOTIATE) {
          // include TelnetNegotiation.ZC here i guess
          ptr += 3;
        }
        else if (*ptr == ANSI_ESC) {
          // ANSI escape sequence
          ptr++;
          if (*ptr == ANSI_CSI) {
            ptr++;
            I64 ansi_code[MAX_ANSI_PARAMS];
            I64 ansi_param_count = 0;
            while (IsDigit(*ptr) || *ptr == ';') {
                if (IsDigit(*ptr)) {
                    ansi_code[ansi_param_count] = ansi_code[ansi_param_count] * 10 + (*ptr - '0');
                    ptr++;
                }
                else if (*ptr == ';') {
                    ansi_param_count++;
                    if (ansi_param_count >= MAX_ANSI_PARAMS) {
                        // Error handling: too many parameters
                        break;
                    }
                    ptr++;
                    if(!IsDigit(*ptr)){
                        break;
                    }
                }
            }

            // Handle specific ANSI escape sequences
            switch (*ptr) {
                case 'n':
                  if (ansi_code[0] == 5) {
                    // Respond with terminal readiness
                    SysLog("reported terminal readiness\n");
                    TCPSocketSendString(sock, "\x1B[0n");
                  }
                  else if (ansi_code[0] == 6) {
                    // Respond with cursor position
                    // U8 response[32] = "\x1B[%d;%dR", window_width, window_height;
                    SysLog("reported cursor position\n");
                    TCPSocketSendString(sock, "\x1B\[25;80R");
                  } 
                  ptr++;
                  break;
                case 'c':
                  // Respond with device attributes
                  SysLog("reported device attributes\n");
                  TCPSocketSendString(sock, "\x1B[?1;0c");
                  ptr++;
                  break;
                case 'm':
                  // I64 fg_code, bg_code;
                  // if (x_code >= 30 && x_code <= 37) {
                  //   fg_code = x_code - 30; // Set foreground color
                  // } else if (y_code >= 40 && y_code <= 47) {
                  //   bg_code = y_code - 40; // Set background color
                  // }
                  I64 m;
                  for (m = 0; m < ansi_param_count; m++) {
                    if (ansi_code[m] <= 10) {
                      // switch (ansi_code[m]) {
                        // case 0: "$$BG$$$$FG$$"; break; // reset
                        // case 1: ""; break; // TODO: bold
                        // case 2: ""; break; // TODO: dim
                        // case 3: ""; break; // TODO: italic
                        // case 4: "$$UL,1$$" + string + "$$UL,0$$"; break; // TODO: underline
                        // case 5: "$$"; break; // TODO: blink
                        // case 6: ""; break; // TODO: fast blink
                        // case 7: "$$IV,1$$" + string + "$$IV,0$$"; break; // TODO: invert
                        // case 8: ""; break; // TODO: hide (rare)
                        // case 9: ""; break; // TODO: strikethrough
                        // case 10: ""; break; // TODO: primary font
                      // }
                    }
                    else if (ansi_code[m] >= 30 && ansi_code[m] <= 37) {
                      // Set foreground color
                      SysLog("ansi_code[%d] = %d\n", m, ansi_code[m]);
                      switch (ansi_code[m]) {
                        case 30: "$$BLACK$$"; break;
                        case 31: "$$RED$$"; break;
                        case 32: "$$GREEN$$"; break;
                        case 33: "$$YELLOW$$"; break;
                        case 34: "$$BLUE$$"; break;
                        case 35: "$$PURPLE$$"; break;
                        case 36: "$$CYAN$$"; break;
                        case 37: "$$WHITE$$"; break;
                        case 39: "$$FG$$"; break; // reset
                        default: break;
                      }
                    }
                    // this is a dumb approach, just do a CatPrint or something
                    // until we properly catch the `;` it will stay fucked
                    else if (ansi_code[m] >= 40 && ansi_code[m] <= 47) {
                      // Set background color
                      SysLog("ansi_code[%d] = %d\n", m, ansi_code[m]);
                      switch (ansi_code[m]) {
                        case 40: "$$BG,BLACK$$"; break;
                        case 41: "$$BG,RED$$"; break;
                        case 42: "$$BG,GREEN$$"; break;
                        case 43: "$$BG,YELLOW$$"; break;
                        case 44: "$$BG,BLUE$$"; break;
                        case 45: "$$BG,PURPLE$$"; break;
                        case 46: "$$BG,CYAN$$"; break;
                        case 47: "$$BG,WHITE$$"; break;
                        case 49: "$$BG$$"; break; // reset
                        default: break;
                      }
                    }
                  }
                  ptr++;
                  break;
                case 'A':
                  // Cursor Up
                  SysLog("Cursor Up\n");
                  // "$$CM+TY,0,-%d$$", ansi_code[0];
                  "$$CM,0,-%d$$", ansi_code[0];
                  ptr++;
                  break;
                case 'B':
                  // Cursor Down
                  SysLog("Cursor Down\n");
                  // "$$CM+TY,0,+%d$$", ansi_code[0];
                  "$$CM,0,%d$$", ansi_code[0];
                  ptr++;
                  break;
                case 'C':
                  // Cursor Right
                  // SysLog("Cursor Right %d %d\n", ansi_param_count, ansi_code[0]);
                  // "$$CM+LX,+%d,0$$", ansi_code[0];
                  "$$CM,%d,0$$", ansi_code[0];
                  ptr++;
                  break;
                case 'D':
                  // Cursor Left
                  SysLog("Cursor Left\n");
                  // "$$CM+TY,-%d,0$$", ansi_code[0];
                  "$$CM,-%d,0$$", ansi_code[0];
                  ptr++;
                  break;
                case 'E':
                  // Cursor Next Line
                  SysLog("Cursor Next Line\n");
                  // "$$CM+TY,0,+%d$$", ansi_code[0];
                  // "\n";
                  ptr++;
                  break;
                case 'F':
                  // Cursor Previous Line
                  SysLog("Cursor Previous Line\n");
                  // "$$CM+LY,0,-%d$$", ansi_code[0];
                  // "\n";
                  ptr++;
                  break;
                case 'G':
                  // Cursor Horizontal Absolute	
                  SysLog("Cursor Horizontal Absolute\n");
                  // "$$CM,%d,0$$", ansi_code[0];
                  // "\n";
                  ptr++;
                  break;
                case 'H':
                case 'f':
                  I64 row = 1, col = 1;  // default values

                  // Parse the row number
                  // if(ansi_code[0] != 0)
                  //   row = ansi_code[0];
                  // if(ansi_code[1] != 0)
                  //   col = ansi_code[1];

                  // SysLog("H or f row:%d, col:%d\n", row, col);
                  // "$$CM,%d,%d$$", row, col;

                  // "$$CM,LE=%d,RE=%d$$", col, row;
                  ptr++;
                  break;
                case 'J':
                  SysLog("J code\n");
                  // Erase in Display
                  if (ansi_code[0] == 0) {
                    // Erase from cursor to end of display
                    // DocDelToNum(Fs->display_doc, Fs->display_doc->cur_entry->line_num);
                  } else if (ansi_code[0] == 1) {
                    // Erase from cursor to beginning of display
                    // DocDelToEntry(Fs->display_doc, Fs->display_doc->cur_entry, FALSE);
                  } else if (ansi_code[0] == 2) {
                    // Erase entire display
                    DocClear;
                  }
                  ptr++;
                  break;
                case 'K':
                  SysLog("K code");
                  // Erase in Line
                  CDocEntry *cur_entry = Fs->display_doc->cur_entry;
                  CDocEntry *next_entry = cur_entry->next;
                  
                  // Delete the current entry
                  if (!(cur_entry->de_flags & (DOCEF_HOLD | DOCEF_FILTER_SKIP))) {
                    Fs->display_doc->cur_entry = next_entry;
                    Fs->display_doc->cur_col = next_entry->min_col;
                    DocEntryDel(Fs->display_doc, cur_entry);
                  }
                  
                  // Create a new entry (line) in its place
                  CDocEntry *new_entry = DocEntryNewTag(Fs->display_doc, cur_entry, "");
                  DocInsEntry(Fs->display_doc, new_entry);
                  
                  ptr++;
                  break;
                case 'S':
                  // TODO: Scroll Up
                  SysLog("Scroll Up");
                  ptr++;
                  break;
                case 'T':
                  // TODO: Scroll Down
                  SysLog("Scroll Down");
                  ptr++;
                  break;
                case '?':
                  ptr++;
                  
                  if (*ptr == 's') SysLog("SaveCurrentCursorPosition\n");
                  if (*ptr == 'u') SysLog("RestoreCurrentCursorPosition\n");

                  I64 code = 0;

                  while (IsDigit(*ptr)) {
                    code = code * 10 + (*ptr - '0');
                    ptr++;
                  }

                  switch (code) {
                    case 25:
                      // if (*ptr == 'l') SysLog("code 25l\n");// Hide cursor
                      // if (*ptr == 'h') SysLog("code 25h\n");// Show cursor
                      ptr++; // Move past 'l' or 'h'
                      break;
                    case 47:
                      if (*ptr == 'l') SysLog("code 47l\n"); // restore screen
                      if (*ptr == 'h') SysLog("code 47h\n"); // save screen
                      ptr++; // Move past 'l' or 'h'
                      break;
                    case 1049:
                      if (*ptr == 'l') SysLog("code 1049l\n"); // enables the alternative buffer
                      if (*ptr == 'h') SysLog("code 1049h\n"); // disables the alternative buffer
                      ptr++; // Move past 'l' or 'h'
                      break;
                    default:
                      ptr++;
                      break;
                  }
                  break;
                case 's':
                  // self.saveCursorPosition();
                  ptr++;
                  break;
                case 'r':
                  // self.restoreCursorPosition();
                  ptr++;
                  break;
                case 'h':
                case 'l':
                  // TODO: Handle 'h' (set mode) or 'l' (reset mode) codes
                  ptr++; // Skip 'h' or 'l'
                  break;
                case '=':
                  SysLog("ScreenMode attempt\n");
                  ptr++;
                  break;
                default:
                  ptr++;
                  break;
            }
          }
        }
        // is this handled by the client or the server?
        else if (*ptr == '|') {
          // U8 code[3];
          // code[0] = ptr++;
          // code[1] = ptr++;
          // code[2] = '\0';
          // I64 fg_code = ToI64(code);
          // AppendColorString(fg_code);
          SysLog("Pipe code: %c%c\n", ptr[1], ptr[2]);
          ptr += 3; // Skip the pipe code characters
          // ptr++;
        }
        else {
          // Print the received character
          HandleControlCodes(*ptr);
          ptr++;
        }
        // Reset ansi_param_count and ansi_code
        ansi_param_count = 0;
        I64 wtv;
        for (wtv = 0; wtv < MAX_ANSI_PARAMS; wtv++) {
            ansi_code[wtv] = 0;
        }
      }

    } else {
      // SysLog("Error: %0x%02X\n", ch);
      "Error: Connection closed by the remote host.\n";
      break;
    }
  }

	// sock(CTCPSocket *)->timeout = 0;
  while (TaskValidate(input_task))
  {
    Refresh;
  }

	// sock(CTCPSocket *)->timeout = TCP_TIMEOUT;
  TCPSocketClose(sock);
  "Telnet connection closed.\n";
}

class CHostForm {
  U8 host[256] format "$$DA-P,LEN=255,A=\"Host:%s\"$$";
  U16 port format "A=\"Port:%d\"";
};

U0 TelnetPrompt() {
  CHostForm form;

  form.host[0] = 0;
  form.port = TELNET_PORT;
  if (PopUpForm(&form)) {
    Telnet(form.host, form.port);
  }
}

// dev server
Telnet("localhost", 8888);
// Telnet("bbs.bottomlessabyss.net", 2023);