// Telnet client for ZealOS by y4my4m
// Public Domain

#define TELNET_PORT 23
#define BUF_SIZE 512

I64 TelnetOpen(U8 *host, U16 port) {
  I64 sock;

  if (host == NULL) {
    return -1;
  }

  sock = TCPConnectionCreate(host, port);
  if (sock <= 0) {
    PrintErr("Failed to connect to %s:%d\n", host, port);
    return sock;
  }

	sock(CTCPSocket *)->timeout = TCP_TIMEOUT;
  
  return sock;
}

U0 AppendColorString(I64 color_code, U8 *buf) {
  U8 *color;
  switch (color_code) {
    case 0: color = "$$BLACK$$"; break;
    case 1: color = "$$RED$$"; break;
    case 2: color = "$$GREEN$$"; break;
    case 3: color = "$$YELLOW$$"; break;
    case 4: color = "$$BLUE$$"; break;
    case 5: color = "$$MAGENTA$$"; break;
    case 6: color = "$$CYAN$$"; break;
    case 7: color = "$$WHITE$$"; break;
    default: color = ""; break;
  }
  "%s%s$$FG$$", color, buf;
}

U0 SendWindowSize(I64 sock, U16 rows, U16 cols) {
  U8 buf[9];

  buf[0] = 0xFF; // IAC
  buf[1] = 0xFA; // SB
  buf[2] = 0x1F; // NAWS (Negotiate About Window Size)
  buf[3] = cols >> 8; // High byte of columns
  buf[4] = cols & 0xFF; // Low byte of columns
  buf[5] = rows >> 8; // High byte of rows
  buf[6] = rows & 0xFF; // Low byte of rows
  buf[7] = 0xFF; // IAC
  buf[8] = 0xF0; // SE

  TCPSocketSendString(sock, buf);
}

U0 SendTerminalType(I64 sock, U8 *terminal_type) {
  U8 response[256];
  I64 len = StrLen(terminal_type);

  response[0] = 0xFF; // IAC
  response[1] = 0xFA; // SB
  response[2] = 0x18; // TERMINAL TYPE
  response[3] = 0x00; // IS
  MemCopy(response + 4, terminal_type, len);

  response[len + 4] = 0xFF; // IAC
  response[len + 5] = 0xF0; // SE
  response[len + 6] = '\0';
  TCPSocketSendString(sock, response);
}

U0 HandleControlCodes(U8 ch) {
  if (ch < 32) { // ASCII code below 32 (control character)
    switch (ch) {
      case 0: // NUL (Null)
        // Typically ignored
        break;
      case 7: // BEL (Bell)
        // Make a beep sound or flash the screen
        Beep;
        break;
      case 8: // BS (Backspace)
        "%c%c%c", 8, ' ', 8; // Move cursor back, erase character, move cursor back again
        break;
      case 9: // HT (Horizontal Tab)
        // Move the cursor to the next tab stop (typically 8 spaces)
        break;
      case 10: // LF (Line Feed)
        "%c", ch;
        break;
      case 11: // VT (Vertical Tab)
        // Move the cursor down one line
        break;
      case 12: // FF (Form Feed)
        DocClear;
        break;
      case 13: // CR (Carriage Return)
        "\r";
		break;
      case 14: // SO (Shift Out)
        // Switch to an alternate character set
        break;
      case 15: // SI (Shift In)
        // Switch back to the default character set
        break;
      // Add cases for other control codes as needed
      default:
        break;
    }
  } else {
    "%c", ch;
  }
}


U0 Telnet(U8 *host, U16 port=TELNET_PORT) {
  I64 sock, bytes_received, input_len;
  U8 buffer[BUF_SIZE], input_buffer[BUF_SIZE], *ptr, ch;
  Bool force_disconnect = FALSE;
  // Bool negotiate = FALSE;

  sock = TelnetOpen(host, port);
  if (sock <= 0) {
    return;
  }

  "$$BG,RED$$$$WHITE$$Connected to %s:%d.$$FG$$$$BG$$\n", host, port;

  while (!force_disconnect) {
    bytes_received = TCPSocketReceive(sock, buffer, BUF_SIZE - 1);
    if (bytes_received > 0) {
      buffer[bytes_received] = '\0';

      // Basic Telnet protocol parser
      ptr = buffer;
      while (*ptr) {
        if (*ptr == 0xFF) { // Telnet negotiation sequence
          U8 negotiation_code = *(ptr + 1);
          U8 option_code = *(ptr + 2);

          // Send a response to the server
          U8 response[3];
          response[0] = 0xFF; // IAC

          if (negotiation_code == 0xFD || negotiation_code == 0xFE) { // DO or DONT
            if (option_code == 0x01) { // Echo
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
              } else {
                response[1] = 0xFC; // WONT
              }
            } else if (option_code == 0x03) { // Suppress Go Ahead
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
              } else {
                response[1] = 0xFC; // WONT
              }
            } else if (option_code == 0x18) { // Terminal Type
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
                response[2] = option_code;
                response[3] = '\0';
                TCPSocketSendString(sock, response);
                SendTerminalType(sock, "ANSI");
                // SendWindowSize(sock, 40, 80);
                ptr += 3;
              } else {
                response[1] = 0xFC; // WONT
              }
            } else {
              response[1] = 0xFC; // WONT
            }
          } else { // WILL or WONT
            response[1] = 0xFE; // DONT
          }

          response[2] = option_code;
          response[3] = '\0';
          // TCPSocketSendString(sock, response);
          ptr += 3;
        } else if (*ptr == 0x1B) {
          // ANSI escape sequence
          ptr++;
          if (*ptr == '[') {
            ptr++;
            I64 ansi_code;
            while (1) {
              ansi_code = 0;
              while (*ptr >= '0' && *ptr <= '9') {
                ansi_code = ansi_code * 10 + (*ptr - '0');
                ptr++;
              }
              // Process ansi_code
              if (*ptr == ';') {
                ptr++; // Move to the next part of the sequence
              } else if (*ptr == 'm') {
                ptr++;
                if (ansi_code >= 30 && ansi_code <= 37) {
                  //Set foreground color
                  Print("%s", AppendColorString(ansi_code - 30, *ptr));
                } else if (ansi_code >= 40 && ansi_code <= 47) {
                  // Set background color
                  Print("%s", AppendColorString(ansi_code - 40, *ptr));
                }
                break;
              } else if (*ptr == 'H') {
                // TODO: Handle cursor positioning
                ptr++;
                break;
              } else if (*ptr == 'J') {
                // TODO: Handle screen clearing
                DocClear;
                ptr++;
                break;
              } else if (*ptr == 'K') {
                // TODO: Handle line clearing
                ptr++;
                break;
              } else if (*ptr == 'C') {
                // Custom 'C' escape code for centering text
                // TODO: Handle the centering here
                ptr++;
                break;
              } else if (*ptr == '?') {
                ptr++; // Skip the '?'
              } else if (*ptr == 'h' || *ptr == 'l') {
                // TODO: Handle 'h' (set mode) or 'l' (reset mode) codes
                ptr++; // Skip 'h' or 'l'
                break;
              } else {
                break; // Invalid character, exit loop
              }
            }
          }
        } else {
          // Print the received character
          HandleControlCodes(*ptr);
          ptr++;
        }
      }

      // should have a timer that checks if data is being received
      // look at the Clocks graphics demo (count.jiffies) maybe
      Sleep(1000);
      // Prompt user for input and send it to the remote host
      "\nEnter your choice: ";

      U8 *line = input_buffer;
      while (1) {
        ch = CharGet(, FALSE);
        if (ch == '\r' || ch == '\n') {
          break;
        }
        if (ch == CH_SHIFT_ESC) { // ESC key
          force_disconnect = TRUE;
          break;
        }
        if (ch == CH_BACKSPACE || ch == 127) { // Backspace or Delete key
          if (line != input_buffer) {
            line--; // Move the pointer back
            "%c%c%c", 8, ' ', 8; // Move the cursor back, erase the character, and move the cursor back again
          }
        } else {
          *line++ = ch;
          HandleControlCodes(ch);
        }
      }
      *line++ = '\r';
      *line++ = '\n';
      *line = '\0';
      
      if (!force_disconnect) {
        // SysLog("Sending: %s\n", input_buffer); // Debugging line
        TCPSocketSendString(sock, line);
		  } else {
        "Force disconnecting...\n";
        break;
      }
    } else {
      "Error: Connection closed by the remote host.\n";
      break;
    }
  }

  TCPSocketClose(sock);
  "Telnet connection closed.\n";
}


class CHostForm {
  U8 host[256] format "$$DA-P,LEN=255,A=\"Host:%s\"$$";
  U16 port format "A=\"Port:%d\"";
};

U0 TelnetPrompt() {
  CHostForm form;

  form.host[0] = 0;
  form.port = TELNET_PORT;
  if (PopUpForm(&form)) {
    Telnet(form.host, form.port);
  }
}

// Dev auto-connect to test server
// Telnet("mbrserver.com");
// Telnet("freechess.org");
Telnet("dura-bbs.net", 6359);
//Telnet("darkrealms.ca");