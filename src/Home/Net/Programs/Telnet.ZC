// Telnet client for ZealOS by y4my4m
// Public Domain

#define TELNET_PORT 23
#define BUF_SIZE 512

I64 TelnetOpen(U8 *host, U16 port) {
  I64 sock;

  if (host == NULL) {
    return -1;
  }

  sock = TCPConnectionCreate(host, port);
  if (sock <= 0) {
    PrintErr("Failed to connect to %s:%d\n", host, port);
    return sock;
  }

  // TODO: needed?
	// sock(CTCPSocket *)->timeout = TCP_TIMEOUT;
	// TCPSocketSendString(sock, 0);

  return sock;
}

// U0 GetColorString(I64 color_code, U8 *buf) {
//   static U8 *color_strings[] = {
//     "$$BLACK$$", "$$RED$$", "$$GREEN$$", "$$YELLOW$$",
//     "$$BLUE$$", "$$MAGENTA$$", "$$CYAN$$", "$$WHITE$$"
//   };

//   if (color_code >= 0 && color_code < 8) {
//     StrCopy(buf, color_strings[color_code]);
//   } else {
//     StrCopy(buf, ""); // Default to empty string if an invalid color code is given
//   }
// }

U0 GetColorString(I64 color_code, U8 *buf) {
  switch (color_code) {
    case 0: StrCopy(buf, "$$BLACK$$"); break;
    case 1: StrCopy(buf, "$$RED$$"); break;
    case 2: StrCopy(buf, "$$GREEN$$"); break;
    case 3: StrCopy(buf, "$$BROWN$$"); break; // ANSI yellow is mapped to ZealOS brown
    case 4: StrCopy(buf, "$$BLUE$$"); break;
    case 5: StrCopy(buf, "$$MAGENTA$$"); break;
    case 6: StrCopy(buf, "$$CYAN$$"); break;
    case 7: StrCopy(buf, "$$GREY$$"); break; // ANSI white is mapped to ZealOS grey
    default: StrCopy(buf, ""); break; // Default to empty string if an invalid color code is given
  }
}

U0 SendWindowSize(I64 sock, U16 rows, U16 cols) {
  U8 buf[9];

  buf[0] = 0xFF; // IAC
  buf[1] = 0xFA; // SB
  buf[2] = 0x1F; // NAWS (Negotiate About Window Size)
  buf[3] = cols >> 8; // High byte of columns
  buf[4] = cols & 0xFF; // Low byte of columns
  buf[5] = rows >> 8; // High byte of rows
  buf[6] = rows & 0xFF; // Low byte of rows
  buf[7] = 0xFF; // IAC
  buf[8] = 0xF0; // SE

  TCPSocketSend(sock, buf, sizeof(buf));
}

U0 SendTerminalType(I64 sock, U8 *terminal_type) {
  U8 response[256];
  I64 len = StrLen(terminal_type);

  response[0] = 0xFF; // IAC
  response[1] = 0xFA; // SB
  response[2] = 0x18; // TERMINAL TYPE
  response[3] = 0x00; // IS
  MemCopy(response + 4, terminal_type, len);
  response[len + 4] = 0xFF; // IAC
  response[len + 5] = 0xF0; // SE

  TCPSocketSend(sock, response, len + 6);
}

U0 TelnetClient(U8 *host, U16 port) {
  I64 sock, bytes_received, input_len;
  U8 buffer[BUF_SIZE], input_buffer[BUF_SIZE], *ptr, ch;
  Bool force_disconnect = FALSE;

  sock = TelnetOpen(host, port);
  if (sock <= 0) {
    return;
  }

  "Connected to %s:%d.\n", host, port;

  while (!force_disconnect) {
    bytes_received = TCPSocketReceive(sock, buffer, BUF_SIZE - 1);
    if (bytes_received > 0) {
      buffer[bytes_received] = '\0';

      // Basic Telnet protocol parser
      ptr = buffer;
      while (*ptr) {
        if (*ptr == 0xFF) { // Telnet negotiation sequence
          U8 negotiation_code = *(ptr + 1);
          U8 option_code = *(ptr + 2);

          // Send a response to the server
          U8 response[3];
          response[0] = 0xFF; // IAC

          if (negotiation_code == 0xFD || negotiation_code == 0xFE) { // DO or DONT
            if (option_code == 0x01) { // Echo
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
              } else {
                response[1] = 0xFC; // WONT
              }
            } else if (option_code == 0x03) { // Suppress Go Ahead
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
              } else {
                response[1] = 0xFC; // WONT
              }
            } else if (option_code == 0x18) { // Terminal Type
              if (negotiation_code == 0xFD) {
                response[1] = 0xFB; // WILL
                TCPSocketSend(sock, response, 3);
                SendTerminalType(sock, "ANSI");
                ptr += 3;
              } else {
                response[1] = 0xFC; // WONT
              }
            } else {
              response[1] = 0xFC; // WONT
            }
          } else { // WILL or WONT
            response[1] = 0xFE; // DONT
          }

          response[2] = option_code;
          TCPSocketSend(sock, response, 3);
          ptr += 3;
        } else if (*ptr == 0x1B) {
          // ANSI escape sequence
          ptr++;
          if (*ptr == '[') {
            ptr++;
            I64 ansi_code;
            while (1) {
              ansi_code = 0;
              while (*ptr >= '0' && *ptr <= '9') {
                ansi_code = ansi_code * 10 + (*ptr - '0');
                ptr++;
              }
              // Process ansi_code
              if (*ptr == ';') {
                ptr++; // Move to next part of the sequence
              } else if (*ptr == 'm' ) {
                ptr++; 
                break;
              } else if (*ptr == 'H' || *ptr == 'J' || *ptr == 'K' ) {
                ptr++; // Move past the current character
                // Process color codes
                if (ansi_code >= 30 && ansi_code <= 37) {
                  // Set foreground color
                  U8 color_buf_fg[16];
                  GetColorString(ansi_code - 30, color_buf_fg);
                  Print(color_buf_fg);
                } else if (ansi_code >= 40 && ansi_code <= 47) {
                  // Set background color
                  U8 color_buf_bg[16];
                  GetColorString(ansi_code - 40, color_buf_bg);
                  Print(color_buf_bg);
                }
                // End of the escape sequence
                break;
              }  else if (*ptr == 'C') {
                // Custom 'C' escape code for centering text
                // TODO: Handle the centering here
                ptr++;
                break;
              } else if (*ptr == '?') {
                ptr++; // Skip the '?'
              } else if (*ptr == 'h' || *ptr == 'l') {
                ptr++; // Skip 'h' or 'l'
                break;
              } else {
                break; // Invalid character, exit loop
              }
            }
          }
        } else {
          // Print the received character
          "%c", *ptr;
          ptr++;
        }
      }

      "\n";
      Sleep(500); // Add a 500 ms delay
      // Prompt user for input and send it to the remote host
      "Enter your choice: ";

      U8 *line = input_buffer;
      while (1) {
        ch = CharGet(, FALSE);
        if (ch == '\r' || ch == '\n') {
          break;
        }
        if (ch == CH_ESC || ch == CH_SHIFT_ESC) { // ESC key
          force_disconnect = TRUE;
          break;
        }
        if (ch == CH_BACKSPACE || ch == 127) { // Backspace or Delete key
          if (line != input_buffer) {
            line--; // Move the pointer back
            "%c%c%c", 8, ' ', 8; // Move the cursor back, erase the character, and move the cursor back again
          }
        } else {
          *line++ = ch;
          "%c", ch;
        }
      }
      *line++ = '\r';
      *line++ = '\n';
      *line = '\0';

      if (!force_disconnect) {
        SysLog("Sending: %s\n", input_buffer); // Debugging line
        TCPSocketSendString(sock, input_buffer);
		  } else {
        "Force disconnecting...\n";
        break;
      }
    } else {
      "Error: Connection closed by the remote host.\n";
      break;
    }
  }

  TCPSocketClose(sock);
  "Telnet connection closed.\n";
}

class CHostForm {
  U8 host[256] format "$$DA-P,LEN=255,A=\"Host:%s\"$$";
  U16 port format "A=\"Port:%d\"";
};

U0 TelnetPrompt() {
  CHostForm form;

  form.host[0] = 0;
  form.port = TELNET_PORT;
  if (PopUpForm(&form)) {
    TelnetClient(form.host, form.port);
  }
}

// Dev auto-connect to test server
TelnetClient("mbrserver.com", 23);