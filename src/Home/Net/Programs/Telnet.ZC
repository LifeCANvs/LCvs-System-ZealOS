// Telnet client for ZealOS by y4my4m
// Public Domain

#define TELNET_PORT 23
#define BUF_SIZE 512

I64 TelnetOpen(U8 *host, U16 port) {
  I64 sock;

  if (host == NULL) {
    return -1;
  }

  sock = TCPConnectionCreate(host, port);
  if (sock <= 0) {
    PrintErr("Failed to connect to %s:%d\n", host, port);
    return sock;
  }

  return sock;
}

// U0 GetColorString(I64 color_code, U8 *buf) {
//   static U8 *color_strings[] = {
//     "$$BLACK$$", "$$RED$$", "$$GREEN$$", "$$YELLOW$$",
//     "$$BLUE$$", "$$MAGENTA$$", "$$CYAN$$", "$$WHITE$$"
//   };

//   if (color_code >= 0 && color_code < 8) {
//     StrCopy(buf, color_strings[color_code]);
//   } else {
//     StrCopy(buf, ""); // Default to empty string if an invalid color code is given
//   }
// }

U0 GetColorString(I64 color_code, U8 *buf) {
  switch (color_code) {
    case 0: StrCopy(buf, "$$BLACK$$"); break;
    case 1: StrCopy(buf, "$$RED$$"); break;
    case 2: StrCopy(buf, "$$GREEN$$"); break;
    case 3: StrCopy(buf, "$$BROWN$$"); break; // ANSI yellow is mapped to ZealOS brown
    case 4: StrCopy(buf, "$$BLUE$$"); break;
    case 5: StrCopy(buf, "$$MAGENTA$$"); break;
    case 6: StrCopy(buf, "$$CYAN$$"); break;
    case 7: StrCopy(buf, "$$GREY$$"); break; // ANSI white is mapped to ZealOS grey
    default: StrCopy(buf, ""); break; // Default to empty string if an invalid color code is given
  }
}

U0 SendWindowSize(I64 sock, U16 rows, U16 cols) {
  U8 buf[9];

  buf[0] = 0xFF; // IAC
  buf[1] = 0xFA; // SB
  buf[2] = 0x1F; // NAWS (Negotiate About Window Size)
  buf[3] = cols >> 8; // High byte of columns
  buf[4] = cols & 0xFF; // Low byte of columns
  buf[5] = rows >> 8; // High byte of rows
  buf[6] = rows & 0xFF; // Low byte of rows
  buf[7] = 0xFF; // IAC
  buf[8] = 0xF0; // SE

  TCPSocketSend(sock, buf, sizeof(buf));
}

U0 SendTerminalType(I64 sock, U8 *term_type) {
  I64 term_type_len = StrLen(term_type);
  U8 buf[6 + StrLen(term_type)];

  buf[0] = 0xFF; // IAC
  buf[1] = 0xFA; // SB
  buf[2] = 0x18; // Terminal Type
  buf[3] = 0x00; // IS
  MemCopy(buf + 4, term_type, term_type_len); // Copy terminal type string
  buf[4 + term_type_len] = 0xFF; // IAC
  buf[5 + term_type_len] = 0xF0; // SE

  TCPSocketSend(sock, buf, 6 + term_type_len);
}

U0 TelnetClient(U8 *host, U16 port) {
  I64 sock, bytes_received, input_len;
  U8 buffer[BUF_SIZE], input_buffer[BUF_SIZE], *ptr, ch;
  Bool force_disconnect = FALSE;

  sock = TelnetOpen(host, port);
  if (sock <= 0) {
    return;
  }

  "Connected to %s:%d.\n", host, port;

  while (!force_disconnect) {
    bytes_received = TCPSocketReceive(sock, buffer, BUF_SIZE - 1);
    if (bytes_received > 0) {
      buffer[bytes_received] = '\0';

      // Basic Telnet protocol parser
      ptr = buffer;
      while (*ptr) {
        if (*ptr == 0xFF) { // Telnet negotiation sequence
          U8 negotiation_code = *(ptr + 1);
          U8 option_code = *(ptr + 2);

          // Send a response to the server
          U8 response[3];
          response[0] = 0xFF; // IAC

          // Check if the negotiation code is DO or DONT
        //   if (negotiation_code == 0xFD || negotiation_code == 0xFE) {
        //     switch (option_code) {
        //       case 0x01: // Echo
        //         response[1] = (negotiation_code == 0xFD) ? 0xFB : 0xFC; // WILL if DO, WONT if DONT
        //         break;
        //       case 0x03: // Suppress Go Ahead
        //         response[1] = (negotiation_code == 0xFD) ? 0xFB : 0xFC; // WILL if DO, WONT if DONT
        //         break;
        //       case 0x18: // Terminal Type
        //         if (negotiation_code == 0xFD) {
        //           response[1] = 0xFB; // WILL
        //           TCPSocketSend(sock, response, 3);
        //           SendTerminalType(sock, "ANSI");
        //           ptr += 3;
        //           continue:
        //         } else {
        //           response[1] = 0xFC; // WONT
        //         }
        //         break;
        //       default:
        //         response[1] = 0xFC; // WONT
        //         break;
        //     }
        //   } else { // Else, assume the negotiation code is WILL or WONT
        //     response[1] = 0xFE; // DONT
        //   }

          // Check if the negotiation code is DO or DONT
          if (negotiation_code == 0xFD && option_code == 0x18) {
            response[1] = 0xFB; // WILL
            TCPSocketSend(sock, response, 3);
            // doesn't seem to work
            SendTerminalType(sock, "ANSI");
            SendWindowSize(sock, 40, 80);
          } else if (negotiation_code == 0xFD || negotiation_code == 0xFE) {
            response[1] = 0xFC; // WONT
          } else { // Else, assume the negotiation code is WILL or WONT
            response[1] = 0xFE; // DONT
          }

          response[2] = option_code;

          TCPSocketSend(sock, response, 3);
          ptr += 3;
        } else if (*ptr == 0x1B) {
          // ANSI escape sequence
          ptr++;
          if (*ptr == '[') {
            ptr++;
            I64 ansi_code;
            while (1) {
              ansi_code = 0;
              while (*ptr >= '0' && *ptr <= '9') {
                ansi_code = ansi_code * 10 + (*ptr - '0');
                ptr++;
              }
              // Process ansi_code
              if (*ptr == ';') {
                ptr++; // Move to next part of the sequence
              } else if (*ptr == 'm' ) {
                ptr++; 
                break;
              } else if (*ptr == 'H' || *ptr == 'J' || *ptr == 'K' ) {
                ptr++; // Move past the current character
                // Process color codes
                // if (ansi_code >= 30 && ansi_code <= 37) {
                //   // Set foreground color
                //   U8 color_buf[16];
                //   GetColorString(ansi_code - 30, color_buf);
                //   Print(color_buf);
                // } else if (ansi_code >= 40 && ansi_code <= 47) {
                //   // Set background color
                //   U8 color_buf[16];
                //   GetColorString(ansi_code - 40, color_buf);
                //   Print(color_buf);
                // }
                I64 zeal_color = 7; // Default color
                if (ansi_code >= 30 && ansi_code <= 37) {
                  zeal_color = ansi_code - 30;
                }
                U8 color_string[16];
                GetColorString(zeal_color, color_string);
				"%s", color_string;
                // End of the escape sequence
                break;
              }  else if (*ptr == 'C') {
                // Custom 'C' escape code for centering text
                // TODO: Handle the centering here
                ptr++;
                break;
              } else if (*ptr == '?') {
                ptr++; // Skip the '?'
              } else if (*ptr == 'h' || *ptr == 'l') {
                ptr++; // Skip 'h' or 'l'
                break;
              } else {
                break; // Invalid character, exit loop
              }
            }
          }
        } else {
          // Print the received character
          "%c", *ptr;
          ptr++;
        }
      }

      "\n";
      Sleep(500); // Add a 500 ms delay
      // Prompt user for input and send it to the remote host
      "Enter your choice: ";

      U8 *line = input_buffer;
      while (1) {
        ch = CharGet(, FALSE);
        if (ch == '\r' || ch == '\n') {
          break;
        }
        if (ch == CH_ESC || ch == CH_SHIFT_ESC) { // ESC key
          force_disconnect = TRUE;
          break;
        }
        if (ch == CH_BACKSPACE || ch == 127) { // Backspace or Delete key
          if (line != input_buffer) {
            line--; // Move the pointer back
            "%c%c%c", 8, ' ', 8; // Move the cursor back, erase the character, and move the cursor back again
          }
        } else {
          *line++ = ch;
		  "%c", ch;
        }
      }
      *line++ = '\r';
      *line++ = '\n';
      *line = '\0';

      if (!force_disconnect) {
        SysLog("Sending: %s\n", input_buffer); // Debugging line
        TCPSocketSendString(sock, input_buffer);
		  } else {
        "Force disconnecting...\n";
        break;
      }
    } else {
      "Error: Connection closed by the remote host.\n";
      break;
    }
  }

  TCPSocketClose(sock);
  "Telnet connection closed.\n";
}

class CHostForm {
  U8 host[256] format "$$DA-P,LEN=255,A=\"Host:%s\"$$";
  U16 port format "A=\"Port:%d\"";
};

U0 TelnetPrompt() {
  CHostForm form;

  form.host[0] = 0;
  form.port = TELNET_PORT;
  if (PopUpForm(&form)) {
    TelnetClient(form.host, form.port);
  }
}

// Dev auto-connect to test server
TelnetClient("mbrserver.com", 23);