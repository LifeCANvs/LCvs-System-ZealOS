U0 GenerateSineWave(U32 *buffer, I64 length, F64 freq, U8 velocity) {
    I64 i;
    F64 amplitude = (ToF64(velocity) / 127.0) * 0x7FFF;  // Adjust the amplitude based on velocity
    F64 phase_increment = (2.0 * PI * freq) / SAMPLE_RATE;  // Assuming a sample rate of 44.1kHz

    F64 phase = 0.0;
    for (i = 0; i < length; i++) {
        I16 sample_value = ToI64((Sin(phase) * amplitude)); // TODO should be ToI16
        buffer[i] = (sample_value << 16) | (sample_value & 0xFFFF);
        phase += phase_increment;
        if (phase >= 2.0 * PI) phase -= 2.0 * PI;
    }
}

U0 GeneratePulse1Wave(U32 *buffer, I64 length, F64 freq, U8 velocity) {
    I64 i;
    F64 amplitude = (ToF64(velocity) / 127.0) * 0x7FFF;
    F64 phase_increment = (2.0 * PI * freq) / SAMPLE_RATE;
    F64 phase = 0.0;
    
    for (i = 0; i < length; i++) {
        I16 sample_value;
        if (phase < PI) {
            sample_value = ToI64(amplitude);
        } else {
            sample_value = -ToI64(amplitude);
        }
        buffer[i] = (sample_value << 16) | (sample_value & 0xFFFF);
        phase += phase_increment;
        if (phase >= 2.0 * PI) phase -= 2.0 * PI;
    }
}

U0 GeneratePulse2Wave(U32 *buffer, I64 length, F64 freq, U8 velocity) {
	I64 i;
	F64 amplitude = (ToF64(velocity) / 127.0) * 0x7FFF;
	F64 phase_increment = (2.0 * PI * freq) / SAMPLE_RATE;
	F64 phase = 0.0;
	
	for (i = 0; i < length; i++) {
		I16 sample_value;
		if (phase < 0.5 * PI) {
			sample_value = -ToI64(amplitude);
		} else {
			sample_value = ToI64(amplitude);
		}
		buffer[i] = (sample_value << 16) | (sample_value & 0xFFFF);
		phase += phase_increment;
		if (phase >= 2.0 * PI) phase -= 2.0 * PI;
	}
}

U0 GenerateTriangleWave(U32 *buffer, I64 length, F64 freq, U8 velocity) {
	I64 i;
	F64 amplitude = (ToF64(velocity) / 127.0) * 0x7FFF;
	F64 phase_increment = (2.0 * PI * freq) / SAMPLE_RATE;
	F64 phase = 0.0;
	
	for (i = 0; i < length; i++) {
		I16 sample_value;
		if (phase < PI) {
			sample_value = ToI64((phase / PI) * amplitude);
		} else {
			sample_value = ToI64((2.0 - (phase / PI)) * amplitude);
		}
		buffer[i] = (sample_value << 16) | (sample_value & 0xFFFF);
		phase += phase_increment;
		if (phase >= 2.0 * PI) phase -= 2.0 * PI;
	}
}

U0 GenerateNoiseWave(U32 *buffer, I64 length, F64 freq, U8 velocity) {
	I64 i;
	F64 amplitude = (ToF64(velocity) / 127.0) * 0x7FFF;
	F64 phase_increment = (2.0 * PI * freq) / SAMPLE_RATE;
	F64 phase = 0.0;
	
	for (i = 0; i < length; i++) {
		I16 sample_value = ToI64((RandI64 / 0x7FFFFFFF) * amplitude);
		buffer[i] = (sample_value << 16) | (sample_value & 0xFFFF);
		phase += phase_increment;
		if (phase >= 2.0 * PI) phase -= 2.0 * PI;
	}
}

U0 ApplyEnvelope(U32 *buffer, I64 length) {
	I64 i;
	for (i = 0; i < length; i++) {
		I64 sample = buffer[i];
		I64 left = sample >> 16;
		I64 right = sample & 0xFFFF;
		left = (left * i) / length;
		right = (right * (length - i)) / length;
		buffer[i] = (left << 16) | (right & 0xFFFF);
	}
}

// U0 ApplyEnvelope(U32 *buffer, I64 length) {
//      I64 fadeLength = length * 0.1;  // 10% fade in and fade out
//  	I64 i;
//      for (i = 0; i < fadeLength; i++) {
//          F64 factor = ToI64(i / fadeLength);
//          buffer[i] = ToI64(buffer[i] * factor);
//          buffer[length - i - 1] = ToI64(buffer[length - i - 1] * factor);
//      }
// }

U0 LoadSample(U8 *filename) {
    //WAVHeader header;
	I64 fileSize;


    // Free any previously loaded sample
    // if (gSampleData) {
    //     Free(gSampleData);
    // }

    gSampleSize = fileSize - sizeof(WAVHeader);

	//gSampleData = MAlloc(gSampleSize);


    //U8 *buffer = FileRead(filename, &fileSize);
	
	//if (buffer)
	//{
	//	MemCopy(&header, buffer, sizeof(WAVHeader));
	//	Print("Got: %c %c %c %c\n", header.riff[0], header.riff[1], header.riff[2], header.riff[3]);
	    // Basic validation - check the RIFF and WAVE tags
    //	if (!StrCompare("RIFF", header.riff) || !StrCompare("WAVE", header.wave)) {
    //    	Print("Invalid WAV file.\n");
	//		Free(buffer);
	//        return;
    //	}


	//} else {
	//	Print("Failed to read the file.\n");
	//}


	//U8 *fileContent = FileRead(filename, &gSampleSize);
	//U8 *audioDataStart = fileContent + sizeof(WAVHeader); // Move pointer after header
	//MemCopy(gSampleData, audioDataStart, gSampleSize);



	// DEBUG
	// gSampleSize = fileSize - 44;

	//U8 *audioDataStart = fileContent + 44; // Move pointer after header MANUAL 36 bytes
	//MemCopy(gSampleData, audioDataStart, gSampleSize);


	//Free(fileContent);

	// test without skipping header

	gSampleData = FileRead(filename, &gSampleSize);

    // Print some info about the sample
    //Print("Sample rate: %d\n", header.sample_rate);
    //Print("Channels: %d\n", header.channels);
    //Print("Bits per sample: %d\n", header.bits_per_sample);


}
// // Clamping function without casting
// I16 ClampI16(I16 value) {
// 	if (value < -32768) return -32768;
// 	if (value > 32767) return 32767;
// 	return value;
// }


F64 GetPlaybackRateMultiplier(U8 targetNote, U8 referenceNote) {
    I64 semitoneDifference = targetNote - referenceNote;
    return Pow(2.0, semitoneDifference / 12.0);
}

U0 PlaySample(U32 *buffer, I64 duration, U8 note, U8 velocity) {
    if (!gSampleData || !gSampleSize) {
        Print("Sample not loaded.\n");
        return;
    }

    // F64 multiplier = GetPlaybackRateMultiplier(note, C3_NOTE_VALUE);
    // Print("Playing with multiplier: %f\n", multiplier); // Add this print statement

    // I64 srcIndex = 0;
	// I64 destIndex;
    // for (destIndex = 0; destIndex < duration; destIndex++) {
    //     if (srcIndex < gSampleSize) {
    //         buffer[destIndex] = gSampleData[srcIndex];
    //         srcIndex = ToI64(srcIndex + multiplier);
    //     } else {
    //         buffer[destIndex] = 0; // fill the rest with silence
    //     }
    // }
    // Print("Last srcIndex: %d\n", srcIndex); // Print the last value of srcIndex after the loop
    // Start after the WAV header

    // I64 destIndex;
    // F64 srcPosition = 44.0; // Start after WAV header


    // for (destIndex = 0; destIndex < duration; destIndex++) {
    //     I64 baseIndex = ToI64(srcPosition);

    //     if (baseIndex < gSampleSize - 8) { // Ensure there are enough samples ahead for interpolation
    //         // Read the two stereo samples we're interpolating between
    //         I16 leftSample1 = (gSampleData[baseIndex + 1] << 8) | gSampleData[baseIndex];
    //         I16 rightSample1 = (gSampleData[baseIndex + 3] << 8) | gSampleData[baseIndex + 2];

    //         I16 leftSample2 = (gSampleData[baseIndex + 5] << 8) | gSampleData[baseIndex + 4];
    //         I16 rightSample2 = (gSampleData[baseIndex + 7] << 8) | gSampleData[baseIndex + 6];

    //         F64 fraction = srcPosition - baseIndex;
	// 		// Linearly interpolate between the two samples for each channel
	// 		I16 leftMixed = ClampI16((1 - fraction) * leftSample1 + fraction * leftSample2);
	// 		I16 rightMixed = ClampI16((1 - fraction) * rightSample1 + fraction * rightSample2);

    //         buffer[destIndex] = (leftMixed & 0xFFFF) | ((rightMixed & 0xFFFF) << 16);
    //     } else {
    //         buffer[destIndex] = 0; // fill the rest with silence
    //     }

    //     srcPosition += 4.0 * multiplier; // Move by one stereo sample, adjusted by the multiplier
    // }

    I64 destIndex;
    F64 srcIndex = 44.0; // Start after WAV header

    for (destIndex = 0; destIndex < duration; destIndex++) {
        F64 realIndex = srcIndex + destIndex * multiplier * 4;
        I64 baseIndex = ToI64(realIndex);
        F64 fraction = realIndex - baseIndex;

        if (baseIndex < gSampleSize - 8) { // Ensure we can access two stereo samples
            U32 leftSample1 = gSampleData[baseIndex] + (gSampleData[baseIndex + 1] << 8);
            U32 rightSample1 = gSampleData[baseIndex + 2] + (gSampleData[baseIndex + 3] << 8);

            U32 leftSample2 = gSampleData[baseIndex + 4] + (gSampleData[baseIndex + 5] << 8);
            U32 rightSample2 = gSampleData[baseIndex + 6] + (gSampleData[baseIndex + 7] << 8);

            // Linear interpolation
            U32 leftSample = leftSample1 + ((leftSample2 - leftSample1) * fraction);
            U32 rightSample = rightSample1 + ((rightSample2 - rightSample1) * fraction);

            buffer[destIndex] = (leftSample & 0xFFFF) | ((rightSample & 0xFFFF) << 16);
        } else {
            buffer[destIndex] = 0; // fill the rest with silence
        }
    }
	Print("Last srcIndex: %d\n", srcIndex);
    
    //F64 playbackStep = 1.0;  // 1.0 means original speed. <1.0 is slower, >1.0 is faster.
    //F64 playbackPointer = 0.0;
	//I64 i;

    //for (i = 0; i < duration; i++) {
    //   if (playbackPointer < gSampleSize) {
    //       buffer[i] = gSampleData[ToI64(playbackPointer)];  // get the sample at the rounded-down playback pointer
    //       playbackPointer += playbackStep;
    //   } else {
    //       buffer[i] = 0;  // or whatever value represents silence in your buffer
    //   }
    //}

	// Simply play the buffer
	//I64 samplesToCopy = Min(gSampleSize, duration); // don't overflow the buffer
    //MemCopy(buffer, gSampleData, samplesToCopy);
}

// I64 sample_rate = SAMPLE_RATE // whatever your sample rate is
// for (I64 i = 0; i < sample_duration * sample_rate; i++) {
//     sample = sin(2.0 * PI * freq * i / sample_rate);
//     // Then send 'sample' to your audio buffer/output.
// }